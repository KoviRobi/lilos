# `lilos` 2: A minimal RTOS

This is a wee RTOS written to support the `async` style of programming in Rust.
It's a research project, a playground, and a proof of concept.

([`lilos` 1](https://github.com/cbiffle/lilos1) was a wee RTOS written to
support multithreaded message-passing programs on AVR.)

# About

`lilos` is somewhat unusual for an RTOS.

This system supports

- Bare metal execution on ARM Cortex-M microprocessors -- not even a `libc` is
  required.

- Arbitrary concurrent tasks, written as sequential programs or state machines.

- Stackless tasks for lower memory consumption.

- Medium-fast response to interrupts, with options for trading off simplicity
  vs. response time.

- Can support fairly complex applications without using dynamic memory *at all.*

- Applications can be written entirely in safe Rust (though `unsafe` can also be
  used, of course).

What makes this system interesting, to me, is what it *doesn't* have:
conventional threads or preemptive multitasking. Instead, the kernel provides a
single thread that can be multiplexed between concurrent *futures*. This sort of
architecture has, in the past, had serious ergonomic consequences: programs
could not be expressed as straight-line sequential code. (See: FreeRTOS
coroutines.)

But that was before systems programming languages supported `async`. With
`async` (sometimes called a "stackless transform" in other languages) we can
express logic as straight-line code, and let the *compiler* turn it into a
stackless state machine.

Concrete example: code to blink an LED on the STM32F407's pin D13.

```rust
use core::time::Duration;
use os::exec::sleep_for;
use stm32f4xx::stm32f407::GPIOD;

async fn blinky_task(gpiod: &GPIOD) -> ! {
    let period = Duration::from_millis(500);
    loop {
        gpiod.bsrr.write(|w| w.bs13().set_bit()); 
        sleep_for(period).await;
        gpiod.bsrr.write(|w| w.br13().set_bit()); 
        sleep_for(period).await;
    }
}
```

# Advantages

Compared to a conventional multitasking operating system, this has several
advantages.

1. It's much easier to reason about, and allocate, stack space. There is only a
   single stack, and the `async` transform means that each future's storage can
   be allocated up-front. The only dynamic portion of the stack is that used to
   evaluate each step in each process.

2. You can easily express concurrency patterns that are somewhere between
   error-prone and downright hard in conventional RTOSes (at least, outside of
   Ada). Need to call two concurrent functions, loaning them each buffers from
   your current stack frame, and then run them concurrently until they both
   return results, before proceeding -- without allocating, using all safe code?
   Easy.

3. `async` opens up the use of normal-looking straight-line code, with loops and
   local variables, in situations where a conventional thread isn't an option,
   such as an interrupt service routine. (I'm not currently making use of this,
   but it is an option.)

4. A simple executor like `lilos` together with `async` takes cooperative
   multitasking, which is already easier to reason about than preemption, and
   adds additional ease. Where can your program yield control? At `await`. This
   is true even if it calls library functions! They can't `await` on your behalf
   unless you let them.

# Disadvantages

I'm still making up my mind about `async`. On the one hand, the stackless
transform is really powerful, and it makes a lot of patterns feasible that
weren't before.

On the other hand,

- The error messages are awful.
- It's really difficult to use in a higher-order style (I've written an
  `AsyncFnMut` trait but it was *not fun*).
- Traits can't contain `async fn`.
- Code size is larger than I'd like.

On the third hand, the Rust features that cause trouble with async aren't even
available in the last language I was using for this sort of thing (C), so ...
still a step up.

# Contact and License

If you have questions, or you use it for something, I'd love to find out! Send
me an email.

I'm experimenting with using the MPL-2 for subversive reasons. I'm open to
relicensing this code if MPL-2 doesn't work for your organization, we'll just
need to discuss your labor practices. ;-)
